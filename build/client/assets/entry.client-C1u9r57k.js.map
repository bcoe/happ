{"version":3,"file":"entry.client-C1u9r57k.js","sources":["../../../node_modules/@remix-run/react/dist/esm/errors.js","../../../node_modules/@remix-run/react/dist/esm/browser.js","../../../node_modules/react-dom/client.js","../../../app/entry.client.tsx"],"sourcesContent":["/**\n * @remix-run/react v2.10.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in remix-server-runtime/errors.ts :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexport { deserializeErrors };\n","/**\n * @remix-run/react v2.10.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createRouter, createBrowserHistory } from '@remix-run/router';\nimport * as React from 'react';\nimport { UNSAFE_mapRouteProperties } from 'react-router';\nimport { matchRoutes, RouterProvider } from 'react-router-dom';\nimport { RemixContext } from './components.js';\nimport { RemixErrorBoundary } from './errorBoundaries.js';\nimport { deserializeErrors } from './errors.js';\nimport { createClientRoutesWithHMRRevalidationOptOut, createClientRoutes, shouldHydrateRouteLoader } from './routes.js';\nimport { decodeViaTurboStream, getSingleFetchDataStrategy } from './single-fetch.js';\nimport invariant from './invariant.js';\nimport { initFogOfWar, useFogOFWarDiscovery } from './fog-of-war.js';\n\n/* eslint-disable prefer-let/prefer-let */\n\n/* eslint-enable prefer-let/prefer-let */\n\nlet stateDecodingPromise;\nlet router;\nlet routerInitialized = false;\nlet hmrAbortController;\nlet hmrRouterReadyResolve;\n// There's a race condition with HMR where the remix:manifest is signaled before\n// the router is assigned in the RemixBrowser component. This promise gates the\n// HMR handler until the router is ready\nlet hmrRouterReadyPromise = new Promise(resolve => {\n  // body of a promise is executed immediately, so this can be resolved outside\n  // of the promise body\n  hmrRouterReadyResolve = resolve;\n}).catch(() => {\n  // This is a noop catch handler to avoid unhandled promise rejection warnings\n  // in the console. The promise is never rejected.\n  return undefined;\n});\n\n// @ts-expect-error\nif (import.meta && import.meta.hot) {\n  // @ts-expect-error\n  import.meta.hot.accept(\"remix:manifest\", async ({\n    assetsManifest,\n    needsRevalidation\n  }) => {\n    let router = await hmrRouterReadyPromise;\n    // This should never happen, but just in case...\n    if (!router) {\n      console.error(\"Failed to accept HMR update because the router was not ready.\");\n      return;\n    }\n    let routeIds = [...new Set(router.state.matches.map(m => m.route.id).concat(Object.keys(window.__remixRouteModules)))];\n    if (hmrAbortController) {\n      hmrAbortController.abort();\n    }\n    hmrAbortController = new AbortController();\n    let signal = hmrAbortController.signal;\n\n    // Load new route modules that we've seen.\n    let newRouteModules = Object.assign({}, window.__remixRouteModules, Object.fromEntries((await Promise.all(routeIds.map(async id => {\n      var _assetsManifest$hmr, _window$__remixRouteM, _window$__remixRouteM2, _window$__remixRouteM3;\n      if (!assetsManifest.routes[id]) {\n        return null;\n      }\n      let imported = await import(assetsManifest.routes[id].module + `?t=${(_assetsManifest$hmr = assetsManifest.hmr) === null || _assetsManifest$hmr === void 0 ? void 0 : _assetsManifest$hmr.timestamp}`);\n      return [id, {\n        ...imported,\n        // react-refresh takes care of updating these in-place,\n        // if we don't preserve existing values we'll loose state.\n        default: imported.default ? ((_window$__remixRouteM = window.__remixRouteModules[id]) === null || _window$__remixRouteM === void 0 ? void 0 : _window$__remixRouteM.default) ?? imported.default : imported.default,\n        ErrorBoundary: imported.ErrorBoundary ? ((_window$__remixRouteM2 = window.__remixRouteModules[id]) === null || _window$__remixRouteM2 === void 0 ? void 0 : _window$__remixRouteM2.ErrorBoundary) ?? imported.ErrorBoundary : imported.ErrorBoundary,\n        HydrateFallback: imported.HydrateFallback ? ((_window$__remixRouteM3 = window.__remixRouteModules[id]) === null || _window$__remixRouteM3 === void 0 ? void 0 : _window$__remixRouteM3.HydrateFallback) ?? imported.HydrateFallback : imported.HydrateFallback\n      }];\n    }))).filter(Boolean)));\n    Object.assign(window.__remixRouteModules, newRouteModules);\n    // Create new routes\n    let routes = createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, assetsManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n    // This is temporary API and will be more granular before release\n    router._internalSetRoutes(routes);\n\n    // Wait for router to be idle before updating the manifest and route modules\n    // and triggering a react-refresh\n    let unsub = router.subscribe(state => {\n      if (state.revalidation === \"idle\") {\n        unsub();\n        // Abort if a new update comes in while we're waiting for the\n        // router to be idle.\n        if (signal.aborted) return;\n        // Ensure RouterProvider setState has flushed before re-rendering\n        setTimeout(() => {\n          Object.assign(window.__remixManifest, assetsManifest);\n          window.$RefreshRuntime$.performReactRefresh();\n        }, 1);\n      }\n    });\n    window.__remixRevalidation = (window.__remixRevalidation || 0) + 1;\n    router.revalidate();\n  });\n}\n\n/**\n * The entry point for a Remix app when it is rendered in the browser (in\n * `app/entry.client.js`). This component is used by React to hydrate the HTML\n * that was received from the server.\n */\nfunction RemixBrowser(_props) {\n  if (!router) {\n    // Hard reload if the path we tried to load is not the current path.\n    // This is usually the result of 2 rapid back/forward clicks from an\n    // external site into a Remix app, where we initially start the load for\n    // one URL and while the JS chunks are loading a second forward click moves\n    // us to a new URL.  Avoid comparing search params because of CDNs which\n    // can be configured to ignore certain params and only pathname is relevant\n    // towards determining the route matches.\n    let initialPathname = window.__remixContext.url;\n    let hydratedPathname = window.location.pathname;\n    if (initialPathname !== hydratedPathname && !window.__remixContext.isSpaMode) {\n      let errorMsg = `Initial URL (${initialPathname}) does not match URL at time of hydration ` + `(${hydratedPathname}), reloading page...`;\n      console.error(errorMsg);\n      window.location.reload();\n      // Get out of here so the reload can happen - don't create the router\n      // since it'll then kick off unnecessary route.lazy() loads\n      return /*#__PURE__*/React.createElement(React.Fragment, null);\n    }\n\n    // When single fetch is enabled, we need to suspend until the initial state\n    // snapshot is decoded into window.__remixContext.state\n    if (window.__remixContext.future.unstable_singleFetch) {\n      // Note: `stateDecodingPromise` is not coupled to `router` - we'll reach this\n      // code potentially many times waiting for our state to arrive, but we'll\n      // then only get past here and create the `router` one time\n      if (!stateDecodingPromise) {\n        let stream = window.__remixContext.stream;\n        invariant(stream, \"No stream found for single fetch decoding\");\n        window.__remixContext.stream = undefined;\n        stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n          window.__remixContext.state = value.value;\n          stateDecodingPromise.value = true;\n        }).catch(e => {\n          stateDecodingPromise.error = e;\n        });\n      }\n      if (stateDecodingPromise.error) {\n        throw stateDecodingPromise.error;\n      }\n      if (!stateDecodingPromise.value) {\n        throw stateDecodingPromise;\n      }\n    }\n    let routes = createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n    let hydrationData = undefined;\n    if (!window.__remixContext.isSpaMode) {\n      // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n      // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n      // render the fallback so we need the client to do the same for hydration.\n      // The server loader data has already been exposed to these route `clientLoader`'s\n      // in `createClientRoutes` above, so we need to clear out the version we pass to\n      // `createBrowserRouter` so it initializes and runs the client loaders.\n      hydrationData = {\n        ...window.__remixContext.state,\n        loaderData: {\n          ...window.__remixContext.state.loaderData\n        }\n      };\n      let initialMatches = matchRoutes(routes, window.location, window.__remixContext.basename);\n      if (initialMatches) {\n        for (let match of initialMatches) {\n          let routeId = match.route.id;\n          let route = window.__remixRouteModules[routeId];\n          let manifestRoute = window.__remixManifest.routes[routeId];\n          // Clear out the loaderData to avoid rendering the route component when the\n          // route opted into clientLoader hydration and either:\n          // * gave us a HydrateFallback\n          // * or doesn't have a server loader and we have no data to render\n          if (route && shouldHydrateRouteLoader(manifestRoute, route, window.__remixContext.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            hydrationData.loaderData[routeId] = undefined;\n          } else if (manifestRoute && !manifestRoute.hasLoader) {\n            // Since every Remix route gets a `loader` on the client side to load\n            // the route JS module, we need to add a `null` value to `loaderData`\n            // for any routes that don't have server loaders so our partial\n            // hydration logic doesn't kick off the route module loaders during\n            // hydration\n            hydrationData.loaderData[routeId] = null;\n          }\n        }\n      }\n      if (hydrationData && hydrationData.errors) {\n        hydrationData.errors = deserializeErrors(hydrationData.errors);\n      }\n    }\n    let {\n      enabled: isFogOfWarEnabled,\n      patchRoutesOnMiss\n    } = initFogOfWar(window.__remixManifest, window.__remixRouteModules, window.__remixContext.future, window.__remixContext.isSpaMode, window.__remixContext.basename);\n\n    // We don't use createBrowserRouter here because we need fine-grained control\n    // over initialization to support synchronous `clientLoader` flows.\n    router = createRouter({\n      routes,\n      history: createBrowserHistory(),\n      basename: window.__remixContext.basename,\n      future: {\n        v7_normalizeFormMethod: true,\n        v7_fetcherPersist: window.__remixContext.future.v3_fetcherPersist,\n        v7_partialHydration: true,\n        v7_prependBasename: true,\n        v7_relativeSplatPath: window.__remixContext.future.v3_relativeSplatPath,\n        // Single fetch enables this underlying behavior\n        unstable_skipActionErrorRevalidation: window.__remixContext.future.unstable_singleFetch === true\n      },\n      hydrationData,\n      mapRouteProperties: UNSAFE_mapRouteProperties,\n      unstable_dataStrategy: window.__remixContext.future.unstable_singleFetch ? getSingleFetchDataStrategy(window.__remixManifest, window.__remixRouteModules) : undefined,\n      ...(isFogOfWarEnabled ? {\n        unstable_patchRoutesOnMiss: patchRoutesOnMiss\n      } : {})\n    });\n\n    // We can call initialize() immediately if the router doesn't have any\n    // loaders to run on hydration\n    if (router.state.initialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n\n    // @ts-ignore\n    router.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;\n    window.__remixRouter = router;\n\n    // Notify that the router is ready for HMR\n    if (hmrRouterReadyResolve) {\n      hmrRouterReadyResolve(router);\n    }\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [criticalCss, setCriticalCss] = React.useState(process.env.NODE_ENV === \"development\" ? window.__remixContext.criticalCss : undefined);\n  if (process.env.NODE_ENV === \"development\") {\n    window.__remixClearCriticalCss = () => setCriticalCss(undefined);\n  }\n\n  // This is due to the short circuit return above when the pathname doesn't\n  // match and we force a hard reload.  This is an exceptional scenario in which\n  // we can't hydrate anyway.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [location, setLocation] = React.useState(router.state.location);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (!routerInitialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n  }, []);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    return router.subscribe(newState => {\n      if (newState.location !== location) {\n        setLocation(newState.location);\n      }\n    });\n  }, [location]);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useFogOFWarDiscovery(router, window.__remixManifest, window.__remixRouteModules, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return (\n    /*#__PURE__*/\n    // This fragment is important to ensure we match the <RemixServer> JSX\n    // structure so that useId values hydrate correctly\n    React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RemixContext.Provider, {\n      value: {\n        manifest: window.__remixManifest,\n        routeModules: window.__remixRouteModules,\n        future: window.__remixContext.future,\n        criticalCss,\n        isSpaMode: window.__remixContext.isSpaMode\n      }\n    }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n      location: location\n    }, /*#__PURE__*/React.createElement(RouterProvider, {\n      router: router,\n      fallbackElement: null,\n      future: {\n        v7_startTransition: true\n      }\n    }))), window.__remixContext.future.unstable_singleFetch ? /*#__PURE__*/React.createElement(React.Fragment, null) : null)\n  );\n}\n\nexport { RemixBrowser };\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","import { RemixBrowser } from \"@remix-run/react\";\nimport { startTransition, StrictMode } from \"react\";\nimport { hydrateRoot } from \"react-dom/client\";\n\nimport { useLocation, useMatches } from '@remix-run/react';\nimport * as Sentry from '@sentry/remix';\nimport { useEffect } from 'react';\n\nSentry.init({\n  debug: true,\n  dsn: 'https://9736cd89fad569a4016ba7ce0d2a79c0@o4506956365430784.ingest.us.sentry.io/4507062370107392',\n  tracesSampleRate: 1,\n  integrations: [\n    Sentry.browserTracingIntegration({\n      useEffect,\n      useLocation,\n      useMatches,\n    }),\n  ]\n});\n\nstartTransition(() => {\n  hydrateRoot(\n    document,\n    <StrictMode>\n      <RemixBrowser />\n    </StrictMode>\n  );\n});\n"],"names":["deserializeErrors","errors","entries","serialized","key","val","UNSAFE_ErrorResponseImpl","ErrorConstructor","error","stateDecodingPromise","router","routerInitialized","hmrRouterReadyResolve","hmrRouterReadyPromise","resolve","RemixBrowser","_props","initialPathname","hydratedPathname","errorMsg","React.createElement","React.Fragment","stream","invariant","decodeViaTurboStream","value","e","routes","createClientRoutes","hydrationData","initialMatches","matchRoutes","match","routeId","route","manifestRoute","shouldHydrateRouteLoader","isFogOfWarEnabled","patchRoutesOnMiss","initFogOfWar","createRouter","createBrowserHistory","UNSAFE_mapRouteProperties","getSingleFetchDataStrategy","createClientRoutesWithHMRRevalidationOptOut","criticalCss","setCriticalCss","React.useState","location","setLocation","React.useLayoutEffect","newState","useFogOFWarDiscovery","RemixContext","RemixErrorBoundary","RouterProvider","m","require$$0","i","hydrateRoot","c","h","o","Sentry.init","Sentry.browserTracingIntegration","useEffect","useLocation","useMatches","startTransition","jsx","StrictMode"],"mappings":"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","x_google_ignoreList":[0,1,2]}