{"version":3,"file":"entry.client-DcuX3XlG.js","sources":["../../../node_modules/@remix-run/react/dist/esm/errorBoundaries.js","../../../node_modules/@remix-run/react/dist/esm/errors.js","../../../node_modules/@remix-run/react/dist/esm/data.js","../../../node_modules/@remix-run/react/dist/esm/fallback.js","../../../node_modules/@remix-run/react/dist/esm/routes.js","../../../node_modules/@remix-run/react/dist/esm/browser.js","../../../node_modules/react-dom/client.js","../../../node_modules/@sentry/react/esm/sdk.js","../../../node_modules/@sentry/remix/esm/client/browserTracingIntegration.js","../../../node_modules/@sentry/remix/esm/index.client.js","../../../app/entry.client.tsx"],"sourcesContent":["/**\n * @remix-run/react v2.8.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { isRouteErrorResponse } from 'react-router-dom';\nimport { useRemixContext, Scripts } from './components.js';\n\nclass RemixErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: props.error || null,\n      location: props.location\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application (even the HTML!) that will have no effect--the error page\n    // continues to display. This gives us a mechanism to recover from the error\n    // when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error || null,\n        location: props.location\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location\n    };\n  }\n  render() {\n    if (this.state.error) {\n      return /*#__PURE__*/React.createElement(RemixRootDefaultErrorBoundary, {\n        error: this.state.error\n      });\n    } else {\n      return this.props.children;\n    }\n  }\n}\n\n/**\n * When app's don't provide a root level ErrorBoundary, we default to this.\n */\nfunction RemixRootDefaultErrorBoundary({\n  error\n}) {\n  console.error(error);\n  let heyDeveloper = /*#__PURE__*/React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n        console.log(\n          \"ðŸ’¿ Hey developer ðŸ‘‹. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information.\"\n        );\n      `\n    }\n  });\n  if (isRouteErrorResponse(error)) {\n    return /*#__PURE__*/React.createElement(BoundaryShell, {\n      title: \"Unhandled Thrown Response!\"\n    }, /*#__PURE__*/React.createElement(\"h1\", {\n      style: {\n        fontSize: \"24px\"\n      }\n    }, error.status, \" \", error.statusText), heyDeveloper);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /*#__PURE__*/React.createElement(BoundaryShell, {\n    title: \"Application Error!\"\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    style: {\n      fontSize: \"24px\"\n    }\n  }, \"Application Error\"), /*#__PURE__*/React.createElement(\"pre\", {\n    style: {\n      padding: \"2rem\",\n      background: \"hsla(10, 50%, 50%, 0.1)\",\n      color: \"red\",\n      overflow: \"auto\"\n    }\n  }, errorInstance.stack), heyDeveloper);\n}\nfunction BoundaryShell({\n  title,\n  renderScripts,\n  children\n}) {\n  var _routeModules$root;\n  let {\n    routeModules\n  } = useRemixContext();\n  if ((_routeModules$root = routeModules.root) !== null && _routeModules$root !== void 0 && _routeModules$root.Layout) {\n    return children;\n  }\n  return /*#__PURE__*/React.createElement(\"html\", {\n    lang: \"en\"\n  }, /*#__PURE__*/React.createElement(\"head\", null, /*#__PURE__*/React.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  }), /*#__PURE__*/React.createElement(\"meta\", {\n    name: \"viewport\",\n    content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n  }), /*#__PURE__*/React.createElement(\"title\", null, title)), /*#__PURE__*/React.createElement(\"body\", null, /*#__PURE__*/React.createElement(\"main\", {\n    style: {\n      fontFamily: \"system-ui, sans-serif\",\n      padding: \"2rem\"\n    }\n  }, children, renderScripts ? /*#__PURE__*/React.createElement(Scripts, null) : null)));\n}\n\nexport { BoundaryShell, RemixErrorBoundary, RemixRootDefaultErrorBoundary };\n","/**\n * @remix-run/react v2.8.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in remix-server-runtime/errors.ts :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexport { deserializeErrors };\n","/**\n * @remix-run/react v2.8.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { AbortedDeferredError, UNSAFE_DeferredData } from '@remix-run/router';\n\n/**\n * Data for a route that was returned from a `loader()`.\n */\n\nfunction isCatchResponse(response) {\n  return response.headers.get(\"X-Remix-Catch\") != null;\n}\nfunction isErrorResponse(response) {\n  return response.headers.get(\"X-Remix-Error\") != null;\n}\nfunction isNetworkErrorResponse(response) {\n  // If we reach the Remix server, we can safely identify response types via the\n  // X-Remix-Error/X-Remix-Catch headers.  However, if we never reach the Remix\n  // server, and instead receive a 4xx/5xx from somewhere in between (like\n  // Cloudflare), then we get a false negative n the isErrorResponse check and\n  // we incorrectly assume that the user returns the 4xx/5xx response and\n  // consider it successful.  To alleviate this, we add X-Remix-Response to any\n  // non-Error/non-Catch responses coming back from the server.  If we don't\n  // see this, we can conclude that a 4xx/5xx response never actually reached\n  // the Remix server and we can bubble it up as an error.\n  return isResponse(response) && response.status >= 400 && response.headers.get(\"X-Remix-Error\") == null && response.headers.get(\"X-Remix-Catch\") == null && response.headers.get(\"X-Remix-Response\") == null;\n}\nfunction isRedirectResponse(response) {\n  return response.headers.get(\"X-Remix-Redirect\") != null;\n}\nfunction isDeferredResponse(response) {\n  var _response$headers$get;\n  return !!((_response$headers$get = response.headers.get(\"Content-Type\")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\\/remix-deferred/));\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nasync function fetchData(request, routeId, retry = 0) {\n  let url = new URL(request.url);\n  url.searchParams.set(\"_data\", routeId);\n  let init = {\n    signal: request.signal\n  };\n  if (request.method !== \"GET\") {\n    init.method = request.method;\n    let contentType = request.headers.get(\"Content-Type\");\n\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      init.headers = {\n        \"Content-Type\": contentType\n      };\n      init.body = JSON.stringify(await request.json());\n    } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n      init.headers = {\n        \"Content-Type\": contentType\n      };\n      init.body = await request.text();\n    } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n      init.body = new URLSearchParams(await request.text());\n    } else {\n      init.body = await request.formData();\n    }\n  }\n  if (retry > 0) {\n    // Retry up to 3 times waiting 50, 250, 1250 ms\n    // between retries for a total of 1550 ms before giving up.\n    await new Promise(resolve => setTimeout(resolve, 5 ** retry * 10));\n  }\n  let revalidation = window.__remixRevalidation;\n  let response = await fetch(url.href, init).catch(error => {\n    if (typeof revalidation === \"number\" && revalidation === window.__remixRevalidation && (error === null || error === void 0 ? void 0 : error.name) === \"TypeError\" && retry < 3) {\n      return fetchData(request, routeId, retry + 1);\n    }\n    throw error;\n  });\n  if (isErrorResponse(response)) {\n    let data = await response.json();\n    let error = new Error(data.message);\n    error.stack = data.stack;\n    return error;\n  }\n  if (isNetworkErrorResponse(response)) {\n    let text = await response.text();\n    let error = new Error(text);\n    error.stack = undefined;\n    return error;\n  }\n  return response;\n}\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nasync function parseDeferredReadableStream(stream) {\n  if (!stream) {\n    throw new Error(\"parseDeferredReadableStream requires stream argument\");\n  }\n  let deferredData;\n  let deferredResolvers = {};\n  try {\n    let sectionReader = readStreamSections(stream);\n\n    // Read the first section to get the critical data\n    let initialSectionResult = await sectionReader.next();\n    let initialSection = initialSectionResult.value;\n    if (!initialSection) throw new Error(\"no critical data\");\n    let criticalData = JSON.parse(initialSection);\n\n    // Setup deferred data and resolvers for later based on the critical data\n    if (typeof criticalData === \"object\" && criticalData !== null) {\n      for (let [eventKey, value] of Object.entries(criticalData)) {\n        if (typeof value !== \"string\" || !value.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX)) {\n          continue;\n        }\n        deferredData = deferredData || {};\n        deferredData[eventKey] = new Promise((resolve, reject) => {\n          deferredResolvers[eventKey] = {\n            resolve: value => {\n              resolve(value);\n              delete deferredResolvers[eventKey];\n            },\n            reject: error => {\n              reject(error);\n              delete deferredResolvers[eventKey];\n            }\n          };\n        });\n      }\n    }\n\n    // Read the rest of the stream and resolve deferred promises\n    void (async () => {\n      try {\n        for await (let section of sectionReader) {\n          // Determine event type and data\n          let [event, ...sectionDataStrings] = section.split(\":\");\n          let sectionDataString = sectionDataStrings.join(\":\");\n          let data = JSON.parse(sectionDataString);\n          if (event === \"data\") {\n            for (let [key, value] of Object.entries(data)) {\n              if (deferredResolvers[key]) {\n                deferredResolvers[key].resolve(value);\n              }\n            }\n          } else if (event === \"error\") {\n            for (let [key, value] of Object.entries(data)) {\n              let err = new Error(value.message);\n              err.stack = value.stack;\n              if (deferredResolvers[key]) {\n                deferredResolvers[key].reject(err);\n              }\n            }\n          }\n        }\n        for (let [key, resolver] of Object.entries(deferredResolvers)) {\n          resolver.reject(new AbortedDeferredError(`Deferred ${key} will never be resolved`));\n        }\n      } catch (error) {\n        // Reject any existing deferred promises if something blows up\n        for (let resolver of Object.values(deferredResolvers)) {\n          resolver.reject(error);\n        }\n      }\n    })();\n    return new UNSAFE_DeferredData({\n      ...criticalData,\n      ...deferredData\n    });\n  } catch (error) {\n    for (let resolver of Object.values(deferredResolvers)) {\n      resolver.reject(error);\n    }\n    throw error;\n  }\n}\nasync function* readStreamSections(stream) {\n  let reader = stream.getReader();\n  let buffer = [];\n  let sections = [];\n  let closed = false;\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  let readStreamSection = async () => {\n    if (sections.length > 0) return sections.shift();\n\n    // Read from the stream until we have at least one complete section to process\n    while (!closed && sections.length === 0) {\n      let chunk = await reader.read();\n      if (chunk.done) {\n        closed = true;\n        break;\n      }\n      // Buffer the raw chunks\n      buffer.push(chunk.value);\n      try {\n        // Attempt to split off a section from the buffer\n        let bufferedString = decoder.decode(mergeArrays(...buffer));\n        let splitSections = bufferedString.split(\"\\n\\n\");\n        if (splitSections.length >= 2) {\n          // We have a complete section, so add it to the sections array\n          sections.push(...splitSections.slice(0, -1));\n          // Remove the section from the buffer and store the rest for future processing\n          buffer = [encoder.encode(splitSections.slice(-1).join(\"\\n\\n\"))];\n        }\n\n        // If we successfully parsed at least one section, break out of reading the stream\n        // to allow upstream processing of the processable sections\n        if (sections.length > 0) {\n          break;\n        }\n      } catch {\n        // If we failed to parse the buffer it was because we failed to decode the stream\n        // because we are missing bytes that we haven't yet received, so continue reading\n        // from the stream until we have a complete section\n        continue;\n      }\n    }\n\n    // If we have a complete section, return it\n    if (sections.length > 0) {\n      return sections.shift();\n    }\n\n    // If we have no complete section, but we have no more chunks to process,\n    // split those sections and clear out the buffer as there is no more data\n    // to process. If this errors, let it bubble up as the stream ended\n    // without valid data\n    if (buffer.length > 0) {\n      let bufferedString = decoder.decode(mergeArrays(...buffer));\n      sections = bufferedString.split(\"\\n\\n\").filter(s => s);\n      buffer = [];\n    }\n\n    // Return any remaining sections that have been processed\n    return sections.shift();\n  };\n  let section = await readStreamSection();\n  while (section) {\n    yield section;\n    section = await readStreamSection();\n  }\n}\nfunction mergeArrays(...arrays) {\n  let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));\n  let offset = 0;\n  for (let arr of arrays) {\n    out.set(arr, offset);\n    offset += arr.length;\n  }\n  return out;\n}\n\nexport { fetchData, isCatchResponse, isDeferredData, isDeferredResponse, isErrorResponse, isNetworkErrorResponse, isRedirectResponse, isResponse, parseDeferredReadableStream };\n","/**\n * @remix-run/react v2.8.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { BoundaryShell } from './errorBoundaries.js';\n\n// If the user sets `clientLoader.hydrate=true` somewhere but does not\n// provide a `HydrateFallback` at any level of the tree, then we need to at\n// least include `<Scripts>` in the SSR so we can hydrate the app and call the\n// `clientLoader` functions\nfunction RemixRootDefaultHydrateFallback() {\n  return /*#__PURE__*/React.createElement(BoundaryShell, {\n    title: \"Loading...\",\n    renderScripts: true\n  }, /*#__PURE__*/React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n              console.log(\n                \"ðŸ’¿ Hey developer ðŸ‘‹. You can provide a way better UX than this \" +\n                \"when your app is running \\`clientLoader\\` functions on hydration. \" +\n                \"Check out https://remix.run/route/hydrate-fallback for more information.\"\n              );\n            `\n    }\n  }));\n}\n\nexport { RemixRootDefaultHydrateFallback };\n","/**\n * @remix-run/react v2.8.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\nimport { useRouteError, redirect } from 'react-router-dom';\nimport { loadRouteModule } from './routeModules.js';\nimport { fetchData, isRedirectResponse, isCatchResponse, isDeferredResponse, parseDeferredReadableStream, isDeferredData, isResponse } from './data.js';\nimport { prefetchStyleLinks } from './links.js';\nimport { RemixRootDefaultErrorBoundary } from './errorBoundaries.js';\nimport { RemixRootDefaultHydrateFallback } from './fallback.js';\nimport invariant from './invariant.js';\n\n// NOTE: make sure to change the Route in server-runtime if you change this\n\n// NOTE: make sure to change the EntryRoute in server-runtime if you change this\n\n// Create a map of routes by parentId to use recursively instead of\n// repeatedly filtering the manifest.\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach(route => {\n    let parentId = route.parentId || \"\";\n    if (!routes[parentId]) {\n      routes[parentId] = [];\n    }\n    routes[parentId].push(route);\n  });\n  return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n  let Component = getRouteModuleComponent(routeModule);\n  // HydrateFallback can only exist on the root route in SPA Mode\n  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : undefined;\n  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? () => /*#__PURE__*/React.createElement(RemixRootDefaultErrorBoundary, {\n    error: useRouteError()\n  }) : undefined;\n  if (route.id === \"root\" && routeModule.Layout) {\n    return {\n      ...(Component ? {\n        element: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(Component, null))\n      } : {\n        Component\n      }),\n      ...(ErrorBoundary ? {\n        errorElement: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(ErrorBoundary, null))\n      } : {\n        ErrorBoundary\n      }),\n      ...(HydrateFallback ? {\n        hydrateFallbackElement: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(HydrateFallback, null))\n      } : {\n        HydrateFallback\n      })\n    };\n  }\n  return {\n    Component,\n    ErrorBoundary,\n    HydrateFallback\n  };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({\n  Component: () => null\n})) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let routeModule = routeModules[route.id];\n    invariant(routeModule, \"No `routeModule` available to create server routes\");\n    let dataRoute = {\n      ...getRouteComponents(route, routeModule, isSpaMode),\n      caseSensitive: route.caseSensitive,\n      id: route.id,\n      index: route.index,\n      path: route.path,\n      handle: routeModule.handle,\n      // For SPA Mode, all routes are lazy except root.  However we tell the\n      // router root is also lazy here too since we don't need a full\n      // implementation - we just need a `lazy` prop to tell the RR rendering\n      // where to stop which is always at the root route in SPA mode\n      lazy: isSpaMode ? () => spaModeLazyPromise : undefined,\n      // For partial hydration rendering, we need to indicate when the route\n      // has a loader/clientLoader, but it won't ever be called during the static\n      // render, so just give it a no-op function so we can render down to the\n      // proper fallback\n      loader: route.hasLoader || route.hasClientLoader ? () => null : undefined\n      // We don't need action/shouldRevalidate on these routes since they're\n      // for a static render\n    };\n    let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, future, isSpaMode) {\n  return createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, \"\", groupRoutesByParentId(manifest), needsRevalidation);\n}\nfunction preventInvalidServerHandlerCall(type, route, isSpaMode) {\n  if (isSpaMode) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You cannot call ${fn} in SPA Mode (routeId: \"${route.id}\")`;\n    console.error(msg);\n    throw new UNSAFE_ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n  let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n  let msg = `You are trying to call ${fn} on a route that does not have a server ` + `${type} (routeId: \"${route.id}\")`;\n  if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n    console.error(msg);\n    throw new UNSAFE_ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nfunction noActionDefinedError(type, routeId) {\n  let article = type === \"clientAction\" ? \"a\" : \"an\";\n  let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to ` + `submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n  console.error(msg);\n  throw new UNSAFE_ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let routeModule = routeModulesCache[route.id];\n    async function fetchServerLoader(request) {\n      if (!route.hasLoader) return null;\n      return fetchServerHandler(request, route);\n    }\n    async function fetchServerAction(request) {\n      if (!route.hasAction) {\n        throw noActionDefinedError(\"action\", route.id);\n      }\n      return fetchServerHandler(request, route);\n    }\n    async function prefetchStylesAndCallHandler(handler) {\n      // Only prefetch links if we exist in the routeModulesCache (critical modules\n      // and navigating back to pages previously loaded via route.lazy).  Initial\n      // execution of route.lazy (when the module is not in the cache) will handle\n      // prefetching style links via loadRouteModuleWithBlockingLinks.\n      let cachedModule = routeModulesCache[route.id];\n      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n      try {\n        return handler();\n      } finally {\n        await linkPrefetchPromise;\n      }\n    }\n    let dataRoute = {\n      id: route.id,\n      index: route.index,\n      path: route.path\n    };\n    if (routeModule) {\n      var _initialState$loaderD, _initialState$errors, _routeModule$clientLo;\n      // Use critical path modules directly\n      Object.assign(dataRoute, {\n        ...dataRoute,\n        ...getRouteComponents(route, routeModule, isSpaMode),\n        handle: routeModule.handle,\n        shouldRevalidate: needsRevalidation ? wrapShouldRevalidateForHdr(route.id, routeModule.shouldRevalidate, needsRevalidation) : routeModule.shouldRevalidate\n      });\n      let initialData = initialState === null || initialState === void 0 ? void 0 : (_initialState$loaderD = initialState.loaderData) === null || _initialState$loaderD === void 0 ? void 0 : _initialState$loaderD[route.id];\n      let initialError = initialState === null || initialState === void 0 ? void 0 : (_initialState$errors = initialState.errors) === null || _initialState$errors === void 0 ? void 0 : _initialState$errors[route.id];\n      let isHydrationRequest = needsRevalidation == null && (((_routeModule$clientLo = routeModule.clientLoader) === null || _routeModule$clientLo === void 0 ? void 0 : _routeModule$clientLo.hydrate) === true || !route.hasLoader);\n      dataRoute.loader = async ({\n        request,\n        params\n      }) => {\n        try {\n          let result = await prefetchStylesAndCallHandler(async () => {\n            invariant(routeModule, \"No `routeModule` available for critical-route loader\");\n            if (!routeModule.clientLoader) {\n              if (isSpaMode) return null;\n              // Call the server when no client loader exists\n              return fetchServerLoader(request);\n            }\n            return routeModule.clientLoader({\n              request,\n              params,\n              async serverLoader() {\n                preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n\n                // On the first call, resolve with the server result\n                if (isHydrationRequest) {\n                  if (initialError !== undefined) {\n                    throw initialError;\n                  }\n                  return initialData;\n                }\n\n                // Call the server loader for client-side navigations\n                let result = await fetchServerLoader(request);\n                let unwrapped = await unwrapServerResponse(result);\n                return unwrapped;\n              }\n            });\n          });\n          return result;\n        } finally {\n          // Whether or not the user calls `serverLoader`, we only let this\n          // stick around as true for one loader call\n          isHydrationRequest = false;\n        }\n      };\n\n      // Let React Router know whether to run this on hydration\n      dataRoute.loader.hydrate = shouldHydrateRouteLoader(route, routeModule, isSpaMode);\n      dataRoute.action = ({\n        request,\n        params\n      }) => {\n        return prefetchStylesAndCallHandler(async () => {\n          invariant(routeModule, \"No `routeModule` available for critical-route action\");\n          if (!routeModule.clientAction) {\n            if (isSpaMode) {\n              throw noActionDefinedError(\"clientAction\", route.id);\n            }\n            return fetchServerAction(request);\n          }\n          return routeModule.clientAction({\n            request,\n            params,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              let result = await fetchServerAction(request);\n              let unwrapped = await unwrapServerResponse(result);\n              return unwrapped;\n            }\n          });\n        });\n      };\n    } else {\n      // If the lazy route does not have a client loader/action we want to call\n      // the server loader/action in parallel with the module load so we add\n      // loader/action as static props on the route\n      if (!route.hasClientLoader) {\n        dataRoute.loader = ({\n          request\n        }) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) return Promise.resolve(null);\n          return fetchServerLoader(request);\n        });\n      }\n      if (!route.hasClientAction) {\n        dataRoute.action = ({\n          request\n        }) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) {\n            throw noActionDefinedError(\"clientAction\", route.id);\n          }\n          return fetchServerAction(request);\n        });\n      }\n\n      // Load all other modules via route.lazy()\n      dataRoute.lazy = async () => {\n        let mod = await loadRouteModuleWithBlockingLinks(route, routeModulesCache);\n        let lazyRoute = {\n          ...mod\n        };\n        if (mod.clientLoader) {\n          let clientLoader = mod.clientLoader;\n          lazyRoute.loader = args => clientLoader({\n            ...args,\n            async serverLoader() {\n              preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n              let response = await fetchServerLoader(args.request);\n              let result = await unwrapServerResponse(response);\n              return result;\n            }\n          });\n        }\n        if (mod.clientAction) {\n          let clientAction = mod.clientAction;\n          lazyRoute.action = args => clientAction({\n            ...args,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              let response = await fetchServerAction(args.request);\n              let result = await unwrapServerResponse(response);\n              return result;\n            }\n          });\n        }\n        if (needsRevalidation) {\n          lazyRoute.shouldRevalidate = wrapShouldRevalidateForHdr(route.id, mod.shouldRevalidate, needsRevalidation);\n        }\n        return {\n          ...(lazyRoute.loader ? {\n            loader: lazyRoute.loader\n          } : {}),\n          ...(lazyRoute.action ? {\n            action: lazyRoute.action\n          } : {}),\n          hasErrorBoundary: lazyRoute.hasErrorBoundary,\n          shouldRevalidate: lazyRoute.shouldRevalidate,\n          handle: lazyRoute.handle,\n          // No need to wrap these in layout since the root route is never\n          // loaded via route.lazy()\n          Component: lazyRoute.Component,\n          ErrorBoundary: lazyRoute.ErrorBoundary\n        };\n      };\n    }\n    let children = createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, route.id, routesByParentId, needsRevalidation);\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\n\n// When an HMR / HDR update happens we opt out of all user-defined\n// revalidation logic and force a revalidation on the first call\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n  let handledRevalidation = false;\n  return arg => {\n    if (!handledRevalidation) {\n      handledRevalidation = true;\n      return needsRevalidation.has(routeId);\n    }\n    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n  };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModule = await loadRouteModule(route, routeModules);\n  await prefetchStyleLinks(route, routeModule);\n\n  // Include all `browserSafeRouteExports` fields, except `HydrateFallback`\n  // since those aren't used on lazily loaded routes\n  return {\n    Component: getRouteModuleComponent(routeModule),\n    ErrorBoundary: routeModule.ErrorBoundary,\n    clientAction: routeModule.clientAction,\n    clientLoader: routeModule.clientLoader,\n    handle: routeModule.handle,\n    links: routeModule.links,\n    meta: routeModule.meta,\n    shouldRevalidate: routeModule.shouldRevalidate\n  };\n}\nasync function fetchServerHandler(request, route) {\n  let result = await fetchData(request, route.id);\n  if (result instanceof Error) {\n    throw result;\n  }\n  if (isRedirectResponse(result)) {\n    throw getRedirect(result);\n  }\n  if (isCatchResponse(result)) {\n    throw result;\n  }\n  if (isDeferredResponse(result) && result.body) {\n    return await parseDeferredReadableStream(result.body);\n  }\n  return result;\n}\nfunction unwrapServerResponse(result) {\n  if (isDeferredData(result)) {\n    return result.data;\n  }\n  if (isResponse(result)) {\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      return result.json();\n    } else {\n      return result.text();\n    }\n  }\n  return result;\n}\nfunction getRedirect(response) {\n  let status = parseInt(response.headers.get(\"X-Remix-Status\"), 10) || 302;\n  let url = response.headers.get(\"X-Remix-Redirect\");\n  let headers = {};\n  let revalidate = response.headers.get(\"X-Remix-Revalidate\");\n  if (revalidate) {\n    headers[\"X-Remix-Revalidate\"] = revalidate;\n  }\n  let reloadDocument = response.headers.get(\"X-Remix-Reload-Document\");\n  if (reloadDocument) {\n    headers[\"X-Remix-Reload-Document\"] = reloadDocument;\n  }\n  return redirect(url, {\n    status,\n    headers\n  });\n}\n\n// Our compiler generates the default export as `{}` when no default is provided,\n// which can lead us to trying to use that as a Component in RR and calling\n// createElement on it.  Patching here as a quick fix and hoping it's no longer\n// an issue in Vite.\nfunction getRouteModuleComponent(routeModule) {\n  if (routeModule.default == null) return undefined;\n  let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n  if (!isEmptyObject) {\n    return routeModule.default;\n  }\n}\nfunction shouldHydrateRouteLoader(route, routeModule, isSpaMode) {\n  return isSpaMode && route.id !== \"root\" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);\n}\n\nexport { createClientRoutes, createClientRoutesWithHMRRevalidationOptOut, createServerRoutes, shouldHydrateRouteLoader };\n","/**\n * @remix-run/react v2.8.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createRouter, createBrowserHistory } from '@remix-run/router';\nimport * as React from 'react';\nimport { UNSAFE_mapRouteProperties } from 'react-router';\nimport { matchRoutes, RouterProvider } from 'react-router-dom';\nimport { RemixContext } from './components.js';\nimport { RemixErrorBoundary } from './errorBoundaries.js';\nimport { deserializeErrors } from './errors.js';\nimport { createClientRoutesWithHMRRevalidationOptOut, createClientRoutes, shouldHydrateRouteLoader } from './routes.js';\n\n/* eslint-disable prefer-let/prefer-let */\n\n/* eslint-enable prefer-let/prefer-let */\n\nlet router;\nlet routerInitialized = false;\nlet hmrAbortController;\nlet hmrRouterReadyResolve;\n// There's a race condition with HMR where the remix:manifest is signaled before\n// the router is assigned in the RemixBrowser component. This promise gates the\n// HMR handler until the router is ready\nlet hmrRouterReadyPromise = new Promise(resolve => {\n  // body of a promise is executed immediately, so this can be resolved outside\n  // of the promise body\n  hmrRouterReadyResolve = resolve;\n}).catch(() => {\n  // This is a noop catch handler to avoid unhandled promise rejection warnings\n  // in the console. The promise is never rejected.\n  return undefined;\n});\n\n// @ts-expect-error\nif (import.meta && import.meta.hot) {\n  // @ts-expect-error\n  import.meta.hot.accept(\"remix:manifest\", async ({\n    assetsManifest,\n    needsRevalidation\n  }) => {\n    let router = await hmrRouterReadyPromise;\n    // This should never happen, but just in case...\n    if (!router) {\n      console.error(\"Failed to accept HMR update because the router was not ready.\");\n      return;\n    }\n    let routeIds = [...new Set(router.state.matches.map(m => m.route.id).concat(Object.keys(window.__remixRouteModules)))];\n    if (hmrAbortController) {\n      hmrAbortController.abort();\n    }\n    hmrAbortController = new AbortController();\n    let signal = hmrAbortController.signal;\n\n    // Load new route modules that we've seen.\n    let newRouteModules = Object.assign({}, window.__remixRouteModules, Object.fromEntries((await Promise.all(routeIds.map(async id => {\n      var _assetsManifest$hmr, _window$__remixRouteM, _window$__remixRouteM2, _window$__remixRouteM3;\n      if (!assetsManifest.routes[id]) {\n        return null;\n      }\n      let imported = await import(assetsManifest.routes[id].module + `?t=${(_assetsManifest$hmr = assetsManifest.hmr) === null || _assetsManifest$hmr === void 0 ? void 0 : _assetsManifest$hmr.timestamp}`);\n      return [id, {\n        ...imported,\n        // react-refresh takes care of updating these in-place,\n        // if we don't preserve existing values we'll loose state.\n        default: imported.default ? ((_window$__remixRouteM = window.__remixRouteModules[id]) === null || _window$__remixRouteM === void 0 ? void 0 : _window$__remixRouteM.default) ?? imported.default : imported.default,\n        ErrorBoundary: imported.ErrorBoundary ? ((_window$__remixRouteM2 = window.__remixRouteModules[id]) === null || _window$__remixRouteM2 === void 0 ? void 0 : _window$__remixRouteM2.ErrorBoundary) ?? imported.ErrorBoundary : imported.ErrorBoundary,\n        HydrateFallback: imported.HydrateFallback ? ((_window$__remixRouteM3 = window.__remixRouteModules[id]) === null || _window$__remixRouteM3 === void 0 ? void 0 : _window$__remixRouteM3.HydrateFallback) ?? imported.HydrateFallback : imported.HydrateFallback\n      }];\n    }))).filter(Boolean)));\n    Object.assign(window.__remixRouteModules, newRouteModules);\n    // Create new routes\n    let routes = createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, assetsManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n    // This is temporary API and will be more granular before release\n    router._internalSetRoutes(routes);\n\n    // Wait for router to be idle before updating the manifest and route modules\n    // and triggering a react-refresh\n    let unsub = router.subscribe(state => {\n      if (state.revalidation === \"idle\") {\n        unsub();\n        // Abort if a new update comes in while we're waiting for the\n        // router to be idle.\n        if (signal.aborted) return;\n        // Ensure RouterProvider setState has flushed before re-rendering\n        setTimeout(() => {\n          Object.assign(window.__remixManifest, assetsManifest);\n          window.$RefreshRuntime$.performReactRefresh();\n        }, 1);\n      }\n    });\n    window.__remixRevalidation = (window.__remixRevalidation || 0) + 1;\n    router.revalidate();\n  });\n}\n\n/**\n * The entry point for a Remix app when it is rendered in the browser (in\n * `app/entry.client.js`). This component is used by React to hydrate the HTML\n * that was received from the server.\n */\nfunction RemixBrowser(_props) {\n  if (!router) {\n    // Hard reload if the path we tried to load is not the current path.\n    // This is usually the result of 2 rapid back/forward clicks from an\n    // external site into a Remix app, where we initially start the load for\n    // one URL and while the JS chunks are loading a second forward click moves\n    // us to a new URL.  Avoid comparing search params because of CDNs which\n    // can be configured to ignore certain params and only pathname is relevant\n    // towards determining the route matches.\n    let initialPathname = window.__remixContext.url;\n    let hydratedPathname = window.location.pathname;\n    if (initialPathname !== hydratedPathname && !window.__remixContext.isSpaMode) {\n      let errorMsg = `Initial URL (${initialPathname}) does not match URL at time of hydration ` + `(${hydratedPathname}), reloading page...`;\n      console.error(errorMsg);\n      window.location.reload();\n      // Get out of here so the reload can happen - don't create the router\n      // since it'll then kick off unnecessary route.lazy() loads\n      return /*#__PURE__*/React.createElement(React.Fragment, null);\n    }\n    let routes = createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n    let hydrationData = undefined;\n    if (!window.__remixContext.isSpaMode) {\n      // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n      // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n      // render the fallback so we need the client to do the same for hydration.\n      // The server loader data has already been exposed to these route `clientLoader`'s\n      // in `createClientRoutes` above, so we need to clear out the version we pass to\n      // `createBrowserRouter` so it initializes and runs the client loaders.\n      hydrationData = {\n        ...window.__remixContext.state,\n        loaderData: {\n          ...window.__remixContext.state.loaderData\n        }\n      };\n      let initialMatches = matchRoutes(routes, window.location);\n      if (initialMatches) {\n        for (let match of initialMatches) {\n          let routeId = match.route.id;\n          let route = window.__remixRouteModules[routeId];\n          let manifestRoute = window.__remixManifest.routes[routeId];\n          // Clear out the loaderData to avoid rendering the route component when the\n          // route opted into clientLoader hydration and either:\n          // * gave us a HydrateFallback\n          // * or doesn't have a server loader and we have no data to render\n          if (route && shouldHydrateRouteLoader(manifestRoute, route, window.__remixContext.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            hydrationData.loaderData[routeId] = undefined;\n          } else if (manifestRoute && !manifestRoute.hasLoader) {\n            // Since every Remix route gets a `loader` on the client side to load\n            // the route JS module, we need to add a `null` value to `loaderData`\n            // for any routes that don't have server loaders so our partial\n            // hydration logic doesn't kick off the route module loaders during\n            // hydration\n            hydrationData.loaderData[routeId] = null;\n          }\n        }\n      }\n      if (hydrationData && hydrationData.errors) {\n        hydrationData.errors = deserializeErrors(hydrationData.errors);\n      }\n    }\n\n    // We don't use createBrowserRouter here because we need fine-grained control\n    // over initialization to support synchronous `clientLoader` flows.\n    router = createRouter({\n      routes,\n      history: createBrowserHistory(),\n      basename: window.__remixContext.basename,\n      future: {\n        v7_normalizeFormMethod: true,\n        v7_fetcherPersist: window.__remixContext.future.v3_fetcherPersist,\n        v7_partialHydration: true,\n        v7_prependBasename: true,\n        v7_relativeSplatPath: window.__remixContext.future.v3_relativeSplatPath\n      },\n      hydrationData,\n      mapRouteProperties: UNSAFE_mapRouteProperties\n    });\n\n    // We can call initialize() immediately if the router doesn't have any\n    // loaders to run on hydration\n    if (router.state.initialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n\n    // @ts-ignore\n    router.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;\n    window.__remixRouter = router;\n\n    // Notify that the router is ready for HMR\n    if (hmrRouterReadyResolve) {\n      hmrRouterReadyResolve(router);\n    }\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [criticalCss, setCriticalCss] = React.useState(process.env.NODE_ENV === \"development\" ? window.__remixContext.criticalCss : undefined);\n  if (process.env.NODE_ENV === \"development\") {\n    window.__remixClearCriticalCss = () => setCriticalCss(undefined);\n  }\n\n  // This is due to the short circuit return above when the pathname doesn't\n  // match and we force a hard reload.  This is an exceptional scenario in which\n  // we can't hydrate anyway.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [location, setLocation] = React.useState(router.state.location);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (!routerInitialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n  }, []);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    return router.subscribe(newState => {\n      if (newState.location !== location) {\n        setLocation(newState.location);\n      }\n    });\n  }, [location]);\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return /*#__PURE__*/React.createElement(RemixContext.Provider, {\n    value: {\n      manifest: window.__remixManifest,\n      routeModules: window.__remixRouteModules,\n      future: window.__remixContext.future,\n      criticalCss,\n      isSpaMode: window.__remixContext.isSpaMode\n    }\n  }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n    location: location\n  }, /*#__PURE__*/React.createElement(RouterProvider, {\n    router: router,\n    fallbackElement: null,\n    future: {\n      v7_startTransition: true\n    }\n  })));\n}\n\nexport { RemixBrowser };\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","import { init as init$1 } from '@sentry/browser';\nimport { applySdkMetadata } from '@sentry/core';\n\n/**\n * Inits the React SDK\n */\nfunction init(options) {\n  const opts = {\n    ...options,\n  };\n\n  applySdkMetadata(opts, 'react');\n\n  init$1(opts);\n}\n\nexport { init };\n//# sourceMappingURL=sdk.js.map\n","import { browserTracingIntegration as browserTracingIntegration$1 } from '@sentry/react';\nimport { setGlobals, startPageloadSpan } from './performance.js';\n\n/**\n * Creates a browser tracing integration for Remix applications.\n * This integration will create pageload and navigation spans.\n */\nfunction browserTracingIntegration(options) {\n  if (options.instrumentPageLoad === undefined) {\n    options.instrumentPageLoad = true;\n  }\n\n  if (options.instrumentNavigation === undefined) {\n    options.instrumentNavigation = true;\n  }\n\n  setGlobals({\n    useEffect: options.useEffect,\n    useLocation: options.useLocation,\n    useMatches: options.useMatches,\n    instrumentNavigation: options.instrumentNavigation,\n  });\n\n  const browserTracingIntegrationInstance = browserTracingIntegration$1({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false,\n  });\n\n  return {\n    ...browserTracingIntegrationInstance,\n    afterAllSetup(client) {\n      browserTracingIntegrationInstance.afterAllSetup(client);\n\n      if (options.instrumentPageLoad) {\n        startPageloadSpan();\n      }\n    },\n  };\n}\n\nexport { browserTracingIntegration };\n//# sourceMappingURL=browserTracingIntegration.js.map\n","import { applySdkMetadata } from '@sentry/core';\nimport { init as init$1, getCurrentScope } from '@sentry/react';\nexport * from '@sentry/react';\nexport { captureRemixErrorBoundaryError } from './client/errors.js';\nexport { remixRouterInstrumentation, withSentry } from './client/performance.js';\nexport { browserTracingIntegration } from './client/browserTracingIntegration.js';\n\nfunction init(options) {\n  const opts = {\n    ...options,\n    environment: options.environment || process.env.NODE_ENV,\n  };\n\n  applySdkMetadata(opts, 'remix', ['remix', 'react']);\n\n  init$1(opts);\n\n  getCurrentScope().setTag('runtime', 'browser');\n}\n\nexport { init };\n//# sourceMappingURL=index.client.js.map\n","import { RemixBrowser } from \"@remix-run/react\";\nimport { startTransition, StrictMode } from \"react\";\nimport { hydrateRoot } from \"react-dom/client\";\n\nimport { useLocation, useMatches } from '@remix-run/react';\nimport * as Sentry from '@sentry/remix';\nimport { useEffect } from 'react';\n\nSentry.init({\n  dsn: 'https://9736cd89fad569a4016ba7ce0d2a79c0@o4506956365430784.ingest.us.sentry.io/4507062370107392',\n  tracesSampleRate: 1,\n  integrations: [\n    Sentry.browserTracingIntegration({\n      useEffect,\n      useLocation,\n      useMatches,\n    }),\n  ]\n});\n\nstartTransition(() => {\n  hydrateRoot(\n    document,\n    <StrictMode>\n      <RemixBrowser />\n    </StrictMode>\n  );\n});\n"],"names":["RemixErrorBoundary","React.Component","props","error","state","React.createElement","RemixRootDefaultErrorBoundary","heyDeveloper","isRouteErrorResponse","BoundaryShell","errorInstance","errorString","title","renderScripts","children","_routeModules$root","routeModules","useRemixContext","Scripts","deserializeErrors","errors","entries","serialized","key","val","UNSAFE_ErrorResponseImpl","ErrorConstructor","isCatchResponse","response","isErrorResponse","isNetworkErrorResponse","isResponse","isRedirectResponse","isDeferredResponse","_response$headers$get","value","isDeferredData","deferred","fetchData","request","routeId","retry","url","init","contentType","resolve","revalidation","data","text","DEFERRED_VALUE_PLACEHOLDER_PREFIX","parseDeferredReadableStream","stream","deferredData","deferredResolvers","sectionReader","readStreamSections","initialSection","criticalData","eventKey","reject","section","event","sectionDataStrings","sectionDataString","err","resolver","AbortedDeferredError","UNSAFE_DeferredData","reader","buffer","sections","closed","encoder","decoder","readStreamSection","chunk","splitSections","mergeArrays","s","arrays","out","total","arr","offset","RemixRootDefaultHydrateFallback","groupRoutesByParentId","manifest","routes","route","parentId","getRouteComponents","routeModule","isSpaMode","Component","getRouteModuleComponent","HydrateFallback","ErrorBoundary","useRouteError","createClientRoutesWithHMRRevalidationOptOut","needsRevalidation","routeModulesCache","initialState","future","createClientRoutes","preventInvalidServerHandlerCall","type","msg","noActionDefinedError","article","routesByParentId","fetchServerLoader","fetchServerHandler","fetchServerAction","prefetchStylesAndCallHandler","handler","cachedModule","linkPrefetchPromise","prefetchStyleLinks","dataRoute","_initialState$loaderD","_initialState$errors","_routeModule$clientLo","wrapShouldRevalidateForHdr","initialData","initialError","isHydrationRequest","params","invariant","result","unwrapServerResponse","shouldHydrateRouteLoader","mod","loadRouteModuleWithBlockingLinks","lazyRoute","clientLoader","args","clientAction","routeShouldRevalidate","handledRevalidation","arg","loadRouteModule","getRedirect","status","headers","revalidate","reloadDocument","redirect","router","routerInitialized","hmrRouterReadyResolve","hmrRouterReadyPromise","RemixBrowser","_props","initialPathname","hydratedPathname","errorMsg","React.Fragment","hydrationData","initialMatches","matchRoutes","match","manifestRoute","createRouter","createBrowserHistory","UNSAFE_mapRouteProperties","criticalCss","setCriticalCss","React.useState","location","setLocation","React.useLayoutEffect","newState","RemixContext","RouterProvider","m","require$$0","i","hydrateRoot","c","h","o","options","opts","applySdkMetadata","init$1","browserTracingIntegration","setGlobals","browserTracingIntegrationInstance","browserTracingIntegration$1","client","startPageloadSpan","getCurrentScope","Sentry.init","Sentry.browserTracingIntegration","useEffect","useLocation","useMatches","startTransition","jsx","StrictMode"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}